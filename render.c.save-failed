#include "render.h"

float vertex[] = {-1, -1, 0,
                   1, -1, 0,
                   1,  1, 0,
                  -1,  1, 0};
float texCoord[] = {0, 1,
                    1, 1,
                    1, 0,
                    0, 0};

RenderPtr rptr;
pthread_t thread;

/**
        Main Loop
**/

void Loop(Settings* st, Data* dt, Render* rd,
          Window* window, Window* popup_window, Window* debug_window,

          Window* scale_trackbar, Window* frames_trackbar,

          Window* title_button, Window* openfile_button, Window* scale_button,
          Window* addscale_button, Window* decscale_button, Window* pause_button,
          Window* sfp_button, Window* sti_button, Window* aot_button, Window* mwt_button,
          Window* tlc_button, Window* trc_button, Window* cnr_button, Window* blc_button,
          Window* brc_button, Window* language_button, Window* exit_button, Window* mwt_window)
{
    MSG msg;
    rd->frame = 0;
    rd->render_thread = 1;
    rd->start_time = GetTime();
    rd->change_frames = 1;
    rd->inaccuracy = 0;
    rd->framed_trackbar = 0;
    rd->loading = 0;

    dt->prev_mode = 0;
    dt->prev_frxo = 0;
    dt->prev_fryo = 0;
    dt->prev_frxd = 0;
    dt->prev_fryd = 0;

    st->sfu = 0;

    rptr.window = window;
    rptr.popup_window = popup_window;
    rptr.debug_window = debug_window;
    rptr.mwt_window = mwt_window;

    /** trackbars **/
    rptr.scale_trackbar = scale_trackbar;
    rptr.frames_trackbar = frames_trackbar;

    /** buttons **/
    rptr.title_button = title_button;           rptr.title_button->hovered = 0;
    rptr.openfile_button = openfile_button;     rptr.openfile_button->hovered = 0;
    rptr.scale_button = scale_button;           rptr.scale_button->hovered = 0;
    rptr.addscale_button = addscale_button;     rptr.addscale_button->hovered = 0;
    rptr.decscale_button = decscale_button;     rptr.decscale_button->hovered = 0;
    rptr.pause_button = pause_button;           rptr.pause_button->hovered = 0;
    rptr.sfp_button = sfp_button;               rptr.sfp_button->hovered = 0;
    rptr.sti_button = sti_button;               rptr.sti_button->hovered = 0;
    rptr.aot_button = aot_button;               rptr.aot_button->hovered = 0;
    rptr.mwt_button = mwt_button;               rptr.mwt_button->hovered = 0;
    rptr.tlc_button = tlc_button;               rptr.tlc_button->hovered = 0;
    rptr.trc_button = trc_button;               rptr.trc_button->hovered = 0;
    rptr.cnr_button = cnr_button;               rptr.cnr_button->hovered = 0;
    rptr.blc_button = blc_button;               rptr.blc_button->hovered = 0;
    rptr.brc_button = brc_button;               rptr.brc_button->hovered = 0;
    rptr.language_button = language_button;     rptr.language_button->hovered = 0;
    rptr.exit_button = exit_button;             rptr.exit_button->hovered = 0;

    rptr.dt = dt;
    rptr.rd = rd;
    rptr.st = st;

    /// Main Loop

    while (IsWindow(rptr.window->hwnd)) {
        if (rptr.rd->loading) { Sleep(1); continue; }

        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }

        if (ChangeFrame(dt, rd)) ShowFrame(window, dt, rd, st);
        Sleep(1);
    }
}

/**
        Windows Proccessing
**/

LRESULT CALLBACK MainWindowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
{
    POINT p; RECT rect;
    switch (msg)
    {
        case WM_CLOSE: {
            if (IsWindow(hwnd))
                DestroyWindow(hwnd);
        }   break;

        case WM_QUIT: {
            PostQuitMessage(0);
        }   break;

        case WM_DROPFILES: {
            DragAcceptFiles(hwnd, FALSE);

            _LoadDropFile((HDROP)wparam, rptr.window, rptr.st, rptr.dt, rptr.rd);

            DragAcceptFiles(hwnd, TRUE);
        }   break;

        case WM_LBUTTONDOWN: {
            pthread_create(&thread, NULL, RenderThread, &rptr);

            if (!IsWindow(rptr.popup_window->hwnd)) SendMessage(hwnd, WM_NCLBUTTONDOWN, HTCAPTION, 0);

            rptr.rd->render_thread = 0; pthread_join(thread, NULL); rptr.rd->render_thread = 1;
        }   break;

        case WM_RBUTTONDOWN: {
            ReleaseWindow(rptr.popup_window);

            rptr.title_button->hovered = 0;
            rptr.openfile_button->hovered = 0;
            rptr.scale_button->hovered = 0;
            rptr.addscale_button->hovered = 0;
            rptr.decscale_button->hovered = 0;
            rptr.pause_button->hovered = 0;
            rptr.sfp_button->hovered = 0;
            rptr.sti_button->hovered = 0;
            rptr.aot_button->hovered = 0;
            rptr.mwt_button->hovered = 0;
            rptr.tlc_button->hovered = 0;
            rptr.trc_button->hovered = 0;
            rptr.cnr_button->hovered = 0;
            rptr.blc_button->hovered = 0;
            rptr.brc_button->hovered = 0;
            rptr.language_button->hovered = 0;
            rptr.exit_button->hovered = 0;

            GetCursorPos(&p);
            SystemParametersInfo(SPI_GETWORKAREA, 0, &rect, 0);

            if (p.x + POPUP_WIDTH > rect.right - rect.left) { p.x = rect.right - rect.left - POPUP_WIDTH; }
            if (p.y + POPUP_HEIGHT > rect.bottom - rect.top) { p.y = rect.bottom - rect.top - POPUP_HEIGHT; }


            /** Resize Window **/

            texCoord[1] = 2 / ((rptr.st->size > 2) ? 2 : rptr.st->size);
            texCoord[2] = 2 / ((rptr.st->size > 2) ? 2 : rptr.st->size);
            texCoord[3] = 2 / ((rptr.st->size > 2) ? 2 : rptr.st->size);
            texCoord[4] = 2 / ((rptr.st->size > 2) ? 2 : rptr.st->size);

            rptr.st->trackbar_size = rptr.st->size; rptr.st->size = 2;

            SetWindowPos(rptr.window->hwnd,
                         HWND_NOTOPMOST,
                         0,
                         0,
                         _GetCollisionSize(rptr.dt->width, rptr.st->size),
                         _GetCollisionSize(rptr.dt->height, rptr.st->size),
                         SWP_NOMOVE);

            DragAcceptFiles(rptr.window->hwnd, FALSE);

            pthread_create(&thread, NULL, RenderThread, &rptr);

            /** Popup Menu **/

            LoadWindow(rptr.popup_window, rptr.st, NULL,
                       "PopupWindow", p.x + 5, p.y + 5, POPUP_WIDTH, POPUP_HEIGHT,
                       1, 0, 0, 0);

            HRGN hrgn = CreateRoundRectRgn(0, 0, POPUP_WIDTH, POPUP_HEIGHT, 5, 5);

            SetWindowRgn(rptr.popup_window->hwnd, hrgn, TRUE);

            /** Buttons **/

            int y = 5;
            LoadButton(rptr.title_button, rptr.popup_window,
                       5, y, POPUP_WIDTH - 10, 25, 15,
                       " ", (int)NULL); // 5

            LoadButton(rptr.openfile_button, rptr.popup_window,
                       5, y += 34, POPUP_WIDTH - 10, 25, 15,
                       " ", 2); // 39

            LoadButton(rptr.scale_button, rptr.popup_window,
                       5, y += 25, 160, 25, 15,
                       " ", (int)NULL); // 64

            LoadButton(rptr.addscale_button, rptr.popup_window,
                       185, y, 30, 25, 15,
                       " ", 4); // 64

            LoadButton(rptr.decscale_button, rptr.popup_window,
                       215, y, 30, 25, 15,
                       " ", 5); // 64

            /** Scale trackbar **/

            LoadTrackBar(rptr.scale_trackbar, rptr.popup_window,
                         10, y += 27, POPUP_WIDTH - 20, 24, 0,
                         1, 200, (int)(rptr.st->trackbar_size * 100), (int)NULL); // 91

            /** Buttons **/

            LoadButton(rptr.pause_button, rptr.popup_window,
                       5, y += 28, POPUP_WIDTH - 10, 25, 15,
                       " ", 6); // 119

            /** Frames trackbar **/

            LoadTrackBar(rptr.frames_trackbar, rptr.popup_window,
                         10, y += 27, POPUP_WIDTH -20, 24, 1,
                         1, rptr.dt->count, rptr.rd->frame - 1, (int)NULL); // 146

            /** Buttons **/

            LoadButton(rptr.sfp_button, rptr.popup_window,
                       5, y += 28, POPUP_WIDTH - 10, 25, 15,
                       " ", 7); // 174

            LoadButton(rptr.aot_button, rptr.popup_window,
                       5, y += 25, POPUP_WIDTH - 10, 25, 15,
                       " ", 9); // 199

            LoadButton(rptr.mwt_button, rptr.popup_window,
                       5, y += 25, POPUP_WIDTH, 25, 15,
                       " ", 10); // 224

            LoadButton(rptr.language_button, rptr.popup_window,
                       5, y += 25, POPUP_WIDTH - 10, 25, 15,
                       " ", 11); // 249

            LoadButton(rptr.exit_button, rptr.popup_window,
                       5, y += 25, POPUP_WIDTH - 10, 25, 15,
                       " ", 12); // 274

            rptr.rd->render_thread = 0; pthread_join(thread, NULL); rptr.rd->render_thread = 1;
        }

        case WM_COMMAND: {
            switch (wparam)
            {
                case 1:
                {
                    pthread_create(&thread, NULL, _LoadSettings, &rptr);
                }   break;
            }
        }   break;

        case WM_USER: {
            if (wparam == 1)
            {
                printf("WM_USER\n");
                SetWindowPos(rptr.window->hwnd,
                             (rptr.st->topmost) ? HWND_TOPMOST : HWND_NOTOPMOST,
                             0,
                             0,
                             _GetCollisionSize(rptr.dt->width, rptr.st->size),
                             _GetCollisionSize(rptr.dt->height, rptr.st->size),
                             SWP_NOMOVE);
            }
            else if (wparam == 2)
            {
                SetWindowPos(rptr.window->hwnd,
                             HWND_NOTOPMOST,
                             0,
                             0,
                             0,
                             0,
                             SWP_NOMOVE | SWP_NOSIZE);
            }
        }

        case WM_KEYDOWN: {
            if (wparam == VK_SPACE)
            {
                if (rptr.rd->change_frames) rptr.rd->change_frames = 0;
                else rptr.rd->change_frames = 1;
            }
            if (wparam == VK_ESCAPE)
            {
                PostMessage(hwnd, WM_CLOSE, 0, 0);
            }
        }   break;

        default: break;
    }
    return DefWindowProc(hwnd, msg, wparam, lparam);
}

LRESULT CALLBACK BusyWindowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
{
    return DefWindowProc(hwnd, msg, wparam, lparam);
}

LRESULT CALLBACK PopupMenuProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
{
    POINT p; RECT rect;
    switch (msg)
    {
        case WM_DESTROY: {
            rptr.rd->render_thread = 0;
            pthread_join(thread, NULL);
            rptr.rd->render_thread = 1;

            rptr.st->size = rptr.st->trackbar_size;

            SetWindowPos(rptr.window->hwnd,
                         (rptr.st->topmost) ? HWND_TOPMOST : HWND_NOTOPMOST,
                         0, 0,
                         _GetCollisionSize(rptr.dt->width, rptr.st->size),
                         _GetCollisionSize(rptr.dt->height, rptr.st->size),
                         SWP_NOMOVE);

            texCoord[1] = 1;
            texCoord[2] = 1;
            texCoord[3] = 1;
            texCoord[4] = 1;

            DragAcceptFiles(rptr.window->hwnd, TRUE);
            WriteSettings(rptr.st);

            PostQuitMessage(0);
        }   break;

        case WM_CLOSE: {
            DestroyWindow(hwnd);
            break;
        }

        case WM_ACTIVATE: {
            if (wparam == WA_INACTIVE &&
                !IsChild(rptr.popup_window->hwnd, (HWND)lparam) &&
                rptr.mwt_window->isactive)
            {
                PostMessage(hwnd, WM_CLOSE, 0, 0);

                if (IsWindow(rptr.mwt_window->hwnd))
                    PostMessage(rptr.mwt_window->hwnd, WM_CLOSE, 0, 0);
            }
        }   break;

        case WM_LBUTTONDOWN: {
            pthread_create(&thread, NULL, RenderThread, &rptr);

            SetFocus(rptr.popup_window->hwnd);
            SendMessage(hwnd, WM_NCLBUTTONDOWN, HTCAPTION, 0);

            rptr.rd->render_thread = 0; pthread_join(thread, NULL); rptr.rd->render_thread = 1;
        }   break;

        case WM_RBUTTONDOWN: {
            ReleaseWindow(rptr.popup_window);

            SendMessage(rptr.window->hwnd, WM_RBUTTONDOWN, HTCAPTION, 0);
        }   break;

        case WM_SETCURSOR: {
            GetCursorPos(&p);

            // PostMessage(rptr.mwt_window->hwnd, WM_USER, 1, 0);
            _IsButtonHovered(rptr.title_button, &p);
            _IsButtonHovered(rptr.openfile_button, &p);
            // _IsButtonHovered(rptr.scale_button, &p);
            _IsButtonHovered(rptr.addscale_button, &p);
            _IsButtonHovered(rptr.decscale_button, &p);
            _IsButtonHovered(rptr.pause_button, &p);
            _IsButtonHovered(rptr.sfp_button, &p);
            // _IsButtonHovered(rptr.sti_button, &p);
            _IsButtonHovered(rptr.aot_button, &p);
            _IsButtonHovered(rptr.language_button, &p);
            _IsButtonHovered(rptr.exit_button, &p);

            if (_IsButtonHovered(rptr.mwt_button, &p)) {
                if (!rptr.mwt_window->isactive)
                {
                    RECT rect; GetWindowRect(rptr.popup_window->hwnd, &rect);
                    printf("[%ld, %ld] [%ld, %ld]\n", rect.left, rect.top, rect.right, rect.bottom);

                    LoadWindow(rptr.mwt_window, rptr.st, NULL, "FrameInfo", rect.left + POPUP_WIDTH, rect.top + 224, MWT_WIDTH, MWT_HEIGHT, 0, 0, 0, 0);

                    HRGN hrgn = CreateRoundRectRgn(0, 0, MWT_WIDTH, MWT_HEIGHT, 5, 5);

                    SetWindowRgn(rptr.mwt_window->hwnd, hrgn, TRUE);

                    rptr.tlc_button->hovered = 0;
                    rptr.trc_button->hovered = 0;
                    rptr.cnr_button->hovered = 0;
                    rptr.blc_button->hovered = 0;
                    rptr.brc_button->hovered = 0;

                    int y = 5;
                    LoadButton(rptr.tlc_button, rptr.mwt_window,
                               5, y, POPUP_WIDTH - 10, 25, 15,
                               " ", (int)NULL);

                }
            }
            else PostMessage(rptr.mwt_window->hwnd, WM_USER, 1, 0);

        }

        case WM_PAINT: {
            rptr.popup_window->hdc = BeginPaint(rptr.popup_window->hwnd,
                                                &rptr.popup_window->ps);

            HBRUSH hbrush = CreateSolidBrush(RGB(250, 250, 250));

            rect.left = 0; rect.top = 0; rect.right = POPUP_WIDTH; rect.bottom = POPUP_HEIGHT;
            FillRect(rptr.popup_window->hdc, &rect, hbrush);
            DeleteObject(hbrush);
            EndPaint(rptr.popup_window->hwnd, &rptr.popup_window->ps);

            rect.left = 10; rect.top = 34; rect.right = POPUP_WIDTH - 10; rect.bottom = 35;
            hbrush = CreateSolidBrush(RGB(210, 210, 210));
            FillRect(rptr.popup_window->hdc, &rect, hbrush);

        }   break;

        case WM_DRAWITEM: {
            LPDRAWITEMSTRUCT item = (LPDRAWITEMSTRUCT)lparam;

            if (item->hwndItem == rptr.title_button->hwnd)
                _InvalidateButton(item, rptr.title_button, APP_NAME, 35, 0);

            else if (item->hwndItem == rptr.openfile_button->hwnd)
                _InvalidateButton(item, rptr.openfile_button, "Open file...", 35, 0);

            else if (item->hwndItem == rptr.scale_button->hwnd) {
                sprintf(rptr.st->str_size, "Scale (%.0f%%)", rptr.st->trackbar_size * 100);
                _InvalidateButton(item, rptr.scale_button, rptr.st->str_size, 35, 0);
            }
            else if (item->hwndItem == rptr.addscale_button->hwnd)
                _InvalidateButton(item, rptr.addscale_button, "+", 10, 0);

            else if (item->hwndItem == rptr.decscale_button->hwnd)
                _InvalidateButton(item, rptr.decscale_button, "-", 10, 0);

            else if (item->hwndItem == rptr.pause_button->hwnd)
                _InvalidateButton(item, rptr.pause_button, "Pause (Space)", 35, 0);

            else if (item->hwndItem == rptr.sfp_button->hwnd)
                _InvalidateButton(item, rptr.sfp_button, "Show frame updates", 35, rptr.st->sfu);

//            else if (item->hwndItem == rptr.sti_button->hwnd)
//            {
//                _InvalidateButton(item, rptr.sti_button, "Show taskbar icon (inactive)", 35);
//            }
            else if (item->hwndItem == rptr.aot_button->hwnd)
                _InvalidateButton(item, rptr.aot_button, "Always on top", 35, rptr.st->topmost);

            else if (item->hwndItem == rptr.mwt_button->hwnd) {
                _InvalidateButton(item, rptr.mwt_button, "Move window to", 35, 0);

                /** Drawing Arrow **/

                HPEN hPen = CreatePen(PS_SOLID, 2, RGB(110, 110, 110));
                HPEN hOldPen = SelectObject(rptr.popup_window->hdc, hPen);

                int x = 227;
                int y = 232;
                int size = 8;

                MoveToEx(rptr.popup_window->hdc, x, y, NULL);
                LineTo(rptr.popup_window->hdc, x + size * 0.75, y + size/2);
                LineTo(rptr.popup_window->hdc, x, y + size);

                SelectObject(rptr.popup_window->hdc, hOldPen);
                DeleteObject(hPen);
            }
            else if (item->hwndItem == rptr.language_button->hwnd) {
                _InvalidateButton(item, rptr.language_button, "Language", 35, 0);

                /** Drawing Arrow **/

                HPEN hPen = CreatePen(PS_SOLID, 2, RGB(110, 110, 110));
                HPEN hOldPen = SelectObject(rptr.popup_window->hdc, hPen);

                int x = 227;
                int y = 257;
                int size = 8;

                MoveToEx(rptr.popup_window->hdc, x, y, NULL);
                LineTo(rptr.popup_window->hdc, x + size * 0.75, y + size/2);
                LineTo(rptr.popup_window->hdc, x, y + size);

                SelectObject(rptr.popup_window->hdc, hOldPen);
                DeleteObject(hPen);
            }
            else if (item->hwndItem == rptr.exit_button->hwnd)
                _InvalidateButton(item, rptr.exit_button, "Close (Esc)", 35, 0);

        }   break;

        case WM_HSCROLL: {
            if ((HWND)lparam == rptr.scale_trackbar->hwnd) {
                rptr.st->pos = SendMessage(rptr.scale_trackbar->hwnd, TBM_GETPOS, 0, 0);

                _ChangeScaleTrackBar(rptr.window, rptr.popup_window,
                                     rptr.scale_trackbar, rptr.scale_button,
                                     rptr.st, rptr.dt, rptr.rd,
                                     rptr.st->pos);
            }
            else {
                SetFocus(rptr.popup_window->hwnd);
                rptr.rd->frame = SendMessage(rptr.frames_trackbar->hwnd, TBM_GETPOS, 0, 0) - 1;
                rptr.rd->framed_trackbar = 1; ShowFrame(rptr.window, rptr.dt, rptr.rd, rptr.st); rptr.rd->framed_trackbar = 0;
            }
        }

        case WM_COMMAND: {
            if ( (wparam == 4 || wparam == 327684) && lparam == (LPARAM)rptr.addscale_button->hwnd) {
                rptr.st->pos = SendMessage(rptr.scale_trackbar->hwnd, TBM_GETPOS, 0, 0) + 1;

                _ChangeScaleTrackBar(rptr.window, rptr.popup_window,
                                     rptr.scale_trackbar, rptr.scale_button,
                                     rptr.st, rptr.dt, rptr.rd,
                                     rptr.st->pos);

                PostMessage(rptr.scale_trackbar->hwnd, TBM_SETPOS, TRUE, rptr.st->pos);
            }

            else if ( (wparam == 5 || wparam == 327685) && lparam == (LPARAM)rptr.decscale_button->hwnd) {
                rptr.st->pos = SendMessage(rptr.scale_trackbar->hwnd, TBM_GETPOS, 0, 0) - 1;

                _ChangeScaleTrackBar(rptr.window, rptr.popup_window,
                                     rptr.scale_trackbar, rptr.scale_button,
                                     rptr.st, rptr.dt, rptr.rd,
                                     rptr.st->pos);

                PostMessage(rptr.scale_trackbar->hwnd, TBM_SETPOS, TRUE, rptr.st->pos);
            }

            else if ( wparam == 2 && (HWND)lparam == rptr.openfile_button->hwnd) {
                PostMessage(rptr.window->hwnd, WM_COMMAND, 1, 0);
                ReleaseWindow(rptr.popup_window);
            }

            switch (wparam) {
                case 6: {
                    if (rptr.rd->change_frames) rptr.rd->change_frames = 0;
                    else rptr.rd->change_frames = 1;
                }   break;
                case 7: {
                    if (rptr.st->sfu)
                        rptr.st->sfu = 0;
                    else
                        rptr.st->sfu = 1;

                    InvalidateRect(rptr.sfp_button->hwnd, NULL, TRUE);
                }   break;
                case 9: {
                    if (rptr.st->topmost)
                        rptr.st->topmost = 0;
                    else
                        rptr.st->topmost = 1;

                    SetWindowPos(rptr.window->hwnd, rptr.st->topmost ? HWND_TOPMOST : HWND_NOTOPMOST,
                                 0, 0, 0, 0,
                                 SWP_NOMOVE | SWP_NOSIZE);
                    InvalidateRect(rptr.aot_button->hwnd, NULL, TRUE);
                    WriteSettings(rptr.st);
                }   break;

                case 11: {
                    PostMessage(rptr.window->hwnd, WM_CLOSE, 0, 0);
                }   break;
            }
        }   break;

        case WM_KEYDOWN: {
            if (wparam == VK_SPACE) {
                if (rptr.rd->change_frames) rptr.rd->change_frames = 0;
                else rptr.rd->change_frames = 1;
            }
            else if (wparam == VK_ESCAPE)
                PostMessage(rptr.window->hwnd, WM_CLOSE, 0, 0);
            else if (wparam == VK_LEFT) {
                if (rptr.rd->change_frames) {
                    PostMessage(rptr.popup_window->hwnd, WM_COMMAND, 327685, (LPARAM)rptr.decscale_button->hwnd);
                }
                else {
                    SetFocus(rptr.popup_window->hwnd);
                    int pos = SendMessage(rptr.frames_trackbar->hwnd, TBM_GETPOS, 0, 0) - 1;
                    if (pos - 1 < 0)
                        rptr.rd->frame = rptr.dt->count - 1;
                    else
                        rptr.rd->frame = pos - 1;
                    PostMessage(rptr.frames_trackbar->hwnd, TBM_SETPOS, TRUE, pos);
                    rptr.rd->framed_trackbar = 1; ShowFrame(rptr.window, rptr.dt, rptr.rd, rptr.st); rptr.rd->framed_trackbar = 0;
                }
            }
            else if (wparam == VK_RIGHT) {
                if (rptr.rd->change_frames) {
                    PostMessage(rptr.popup_window->hwnd, WM_COMMAND, 327684, (LPARAM)rptr.addscale_button->hwnd);
                }
                else {
                    SetFocus(rptr.popup_window->hwnd);
                    int pos = SendMessage(rptr.frames_trackbar->hwnd, TBM_GETPOS, 0, 0);
                    if (pos + 1 > rptr.dt->count)
                        rptr.rd->frame = 0;
                    else
                        rptr.rd->frame = pos + 1;
                    PostMessage(rptr.frames_trackbar->hwnd, TBM_SETPOS, TRUE, pos);
                    rptr.rd->framed_trackbar = 1; ShowFrame(rptr.window, rptr.dt, rptr.rd, rptr.st); rptr.rd->framed_trackbar = 0;
                }
            }
            else
                PostMessage(rptr.popup_window->hwnd, WM_CLOSE, 0, 0);

        }   break;

        default: break;
    }
    return DefWindowProc(hwnd, msg, wparam, lparam);
}

LRESULT CALLBACK MWTProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
{
    static int mouseinside = 0;
    POINT p;
    switch (msg)
    {

        case WM_DESTROY: {
            PostQuitMessage(0);
        }   break;

        case WM_CLOSE: {
            DestroyWindow(hwnd);
            rptr.mwt_window->isactive = 0;
            break;
        }

        case WM_PAINT: {
            RECT rect;
            rptr.mwt_window->hdc = BeginPaint(rptr.mwt_window->hwnd,
                                                &rptr.mwt_window->ps);

            HBRUSH hbrush = CreateSolidBrush(RGB(250, 250, 250));

            rect.left = 0; rect.top = 0; rect.right = MWT_WIDTH; rect.bottom = MWT_HEIGHT;
            FillRect(rptr.mwt_window->hdc, &rect, hbrush);
            DeleteObject(hbrush);
            EndPaint(rptr.mwt_window->hwnd, &rptr.mwt_window->ps);
        }   break;

        case WM_SETCURSOR:
        {
            GetCursorPos(&p);

            _IsButtonHovered(rptr.tlc_button, &p);
        }   break;

        case WM_DRAWITEM:
        {
            LPDRAWITEMSTRUCT item = (LPDRAWITEMSTRUCT)lparam;

            if (item->hwndItem == rptr.tlc_button->hwnd)
                _InvalidateButton(item, rptr.tlc_button, "Top left corner", 35, 0);
        }   break;

        /** Checks whether window should exist **/

        case WM_CREATE: {
            RECT rt;
            POINT pt = { 0, 0 };

            GetClientRect(hwnd, &rt);
            ClientToScreen(hwnd, &pt);
            OffsetRect(&rt, pt.x, pt.y);

            GetCursorPos(&pt);

            mouseinside = PtInRect(&rt, pt);
        }   break;

        case WM_ACTIVATE: {
            POINT p; GetCursorPos(&p);
            if (wparam == WA_INACTIVE &&
                !IsChild(rptr.mwt_window->hwnd, (HWND)lparam) &&
                (HWND)lparam != rptr.mwt_window->hwnd)
            {
                printf("WM_ACTIVATE\n");
                PostMessage(hwnd, WM_CLOSE, 0, 0);
            }
        }   break;

        case WM_USER: {
            POINT p;
            GetCursorPos(&p);
            if (rptr.mwt_window->hovered &&
                rptr.mwt_button->hovered &&
                rptr.tlc_button->hovered)
            {
                PostMessage(rptr.mwt_window->hwnd, WM_CLOSE, 0, 0);
            }

        }

        case WM_MOUSEMOVE: {
            TRACKMOUSEEVENT tme;
            tme.cbSize = sizeof(tme);
            tme.hwndTrack = hwnd;
            tme.dwFlags = TME_LEAVE;

            _TrackMouseEvent(&tme);

            if(!mouseinside)
            {
                mouseinside = 1;
                InvalidateRect(hwnd, NULL, FALSE);
                UpdateWindow(hwnd);
            }
        }   break;

        case WM_MOUSELEAVE: {
            mouseinside = FALSE;
            InvalidateRect(hwnd, NULL, FALSE);
            UpdateWindow(hwnd);

            POINT p;
            GetCursorPos(&p);
            if (rptr.mwt_window->hovered &&
                rptr.mwt_button->hovered &&
                rptr.tlc_button->hovered)
            {
                printf("WM_MOUSELEAVE\n");
                PostMessage(rptr.mwt_window->hwnd, WM_CLOSE, 0, 0);
            }
        }   break;

        default: break;
    }
    return DefWindowProc(hwnd, msg, wparam, lparam);
}

void _InvalidateButton(LPDRAWITEMSTRUCT item, Window* window,
                       const char* text, int left, int activated)
{
    HDC hdc = item->hDC;
    RECT rect = item->rcItem;

    SetBkMode(hdc, TRANSPARENT);
    SetTextColor(hdc, RGB(30, 30, 30));
    HBRUSH hBrush = CreateSolidBrush(
        (window->hovered) ? RGB(242, 242, 242) : RGB(250, 250, 250)
    );
    FillRect(hdc, &rect, hBrush);
    DeleteObject(hBrush);
    rect.left = left;
    DrawText(hdc, text, -1, &rect, DT_VCENTER | DT_SINGLELINE);

    if (activated) {
        int size = 20;
        int x = rect.left - 25;
        int y = rect.top + (rect.bottom - rect.top - size) / 2;

        HFONT hFont = CreateFont(size, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE,
                               DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                               DEFAULT_QUALITY, DEFAULT_PITCH, "Marlett");
        HFONT hOldFont = (HFONT)SelectObject(hdc, hFont);
        COLORREF oldColor = SetTextColor(hdc, RGB(30, 30, 30));
        int oldBkMode = SetBkMode(hdc, TRANSPARENT);

        TextOutW(hdc, x, y, L"a", 1);

        SetBkMode(hdc, oldBkMode);
        SetTextColor(hdc, oldColor);
        SelectObject(hdc, hOldFont);
        DeleteObject(hFont);
    }
}

int _IsButtonHovered(Window* window, POINT* p)
{
    RECT rect; GetWindowRect(window->hwnd, &rect);
    if (PtInRect(&rect, *p) && !window->hovered) { window->hovered = 1; InvalidateRect(window->hwnd, NULL, TRUE); }
    else if (!PtInRect(&rect, *p) && window->hovered) { window->hovered = 0; InvalidateRect(window->hwnd, NULL, TRUE); }
    return window->hovered;
}

int _GetCollisionSize(int n, float size)
{
    return (n * size < 10.0) ? 10.0 : n * size + size;
}

void _ChangeScaleTrackBar(Window* window, Window* popup_window,
                          Window* scale_trackbar, Window* scale_button,
                          Settings* st, Data* dt,
                          Render* rd, int pos)
{
    SetFocus(popup_window->hwnd);

    if (pos < 1) pos = 1;
    else if (pos > 200) pos = 200;

    texCoord[1] = 2 / ((float)pos / 100);
    texCoord[2] = 2 / ((float)pos / 100);
    texCoord[3] = 2 / ((float)pos / 100);
    texCoord[4] = 2 / ((float)pos / 100);

    st->trackbar_size = (float)pos / 100;

    sprintf(st->str_size, "Scale (%.0f%%)", st->trackbar_size * 100);
    SetWindowText(scale_button->hwnd, st->str_size);

    if (rd->change_frames)
    {
        rd->change_frames = 0; ShowFrame(window, dt, rd, st); rd->change_frames = 1;
    }
    else
        ShowFrame(window, dt, rd, st);
}

/**
        OpenGL Proccessing
**/

void ShowFrame(Window* window, Data* dt, Render* rd, Settings* st)
{
    wglMakeCurrent(window->hdc, window->hrc);

    RECT rect; GetWindowRect(window->hwnd, &rect);

//    printf("\33[2K\r");
//    printf("Frame: %d | [%ld, %ld] | [%f, %f] [%f, %f]", rd->frame + 1,
//           rect.right - rect.left,
//           rect.bottom - rect.top,
//           dt->frame_points[rd->frame * 4],
//           dt->frame_points[(rd->frame * 4) + 1],
//           dt->frame_points[(rd->frame * 4) + 2],
//           dt->frame_points[(rd->frame * 4) + 3]);

    glViewport(0, 0, _GetCollisionSize(dt->width, st->size),
                     _GetCollisionSize(dt->height, st->size));

    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

    glClearColor(0, 0, 0, 0); glClear(GL_COLOR_BUFFER_BIT);

    glEnable(GL_TEXTURE_2D);
    glBindTexture(GL_TEXTURE_2D, dt->textures[rd->frame]);

    glColor4f(1, 1, 1, 1);

    glPushMatrix();
    glEnableClientState(GL_VERTEX_ARRAY);
    glEnableClientState(GL_TEXTURE_COORD_ARRAY);

    glVertexPointer(3, GL_FLOAT, 0, vertex);
    glTexCoordPointer(2, GL_FLOAT, 0, texCoord);
    glDrawArrays(GL_TRIANGLE_FAN, 0, 4);

    glDisableClientState(GL_VERTEX_ARRAY);
    glDisableClientState(GL_TEXTURE_COORD_ARRAY);

    glPopMatrix();
    glBindTexture(GL_TEXTURE_2D, 0);
    glDisable(GL_TEXTURE_2D);

    /** **/
    if (st->sfu)
    {
        glViewport(0,
                   _GetCollisionSize(dt->height, st->size) - _GetCollisionSize(dt->height, st->trackbar_size),
                   _GetCollisionSize(dt->width, st->trackbar_size),
                   _GetCollisionSize(dt->height, st->trackbar_size));

        glColor4f(1.0, 0.0, 0.0, 1.0);
        glLineWidth(1.0f);

        glBegin(GL_LINE_LOOP);
            glVertex2f(dt->frame_points[rd->frame * 4],
                       dt->frame_points[rd->frame * 4 + 3]);
            glVertex2f(dt->frame_points[rd->frame * 4 + 2],
                       dt->frame_points[rd->frame * 4 + 3]);
            glVertex2f(dt->frame_points[rd->frame * 4 + 2],
                       dt->frame_points[rd->frame * 4 + 1]);
            glVertex2f(dt->frame_points[rd->frame * 4],
                       dt->frame_points[rd->frame * 4 + 1]);
        glEnd();
    }

    SwapBuffers(window->hdc);

    if (!rd->framed_trackbar)
        PostMessage(rptr.frames_trackbar->hwnd, TBM_SETPOS, TRUE, rd->frame + 1);

    if (rd->frame == dt->count - 1 && rd->change_frames) rd->frame = 0;
    else if (rd->change_frames) rd->frame++;

    wglMakeCurrent(NULL, NULL);
}

void ShowLoadLine(Window* window, Data* dt, Settings* st, float pt)
{
    wglMakeCurrent(window->hdc, window->hrc);

    RECT rect; GetWindowRect(window->hwnd, &rect);

    glViewport(0, 0, _GetCollisionSize(rect.right - rect.left, st->size),
                     _GetCollisionSize(rect.bottom - rect.top, st->size));

    glClearColor(0, 0, 0, 0); glClear(GL_COLOR_BUFFER_BIT);

    glColor4f(1.0, 0.0, 0.0, 1.0);
    glLineWidth(1.0f);

    pt *= 1.9999f;

    glBegin(GL_LINE_LOOP);
        glVertex2f(-0.9999f, 0.9999f - pt);
        glVertex2f(-0.995f, 0.995f);
        glVertex2f(pt - 0.995f, 0.995f);
        glVertex2f(pt - 0.9999f, 0.9999f - pt);
    glEnd();

    SwapBuffers(window->hdc);

    wglMakeCurrent(NULL, NULL);
}

void* RenderThread(void* arg)
{
    RenderPtr* rptr = (RenderPtr*)arg;
    while (rptr->rd->render_thread) {
        if (ChangeFrame(rptr->dt, rptr->rd)) ShowFrame(rptr->window, rptr->dt, rptr->rd, rptr->st);
        Sleep(1);
    }

    return NULL;
}

/**
        Time Proccessing
**/

double GetTime()
{
    LARGE_INTEGER freq, counter;
    QueryPerformanceFrequency(&freq);
    QueryPerformanceCounter(&counter);
    return (double)counter.QuadPart / freq.QuadPart;
}

int ChangeFrame(Data* dt, Render* rd)
{
    rd->current_time = GetTime();

    if (rd->current_time - 0.002 > rd->start_time + dt->delays[rd->frame] + rd->inaccuracy)
    {
        rd->current_time = GetTime();
        rd->inaccuracy += dt->delays[rd->frame] - (rd->current_time - rd->start_time);

        if (rd->inaccuracy < -dt->delays[rd->frame] * 2)
            rd->inaccuracy = 0;

        // printf("%f | %f | %f | %f\n", rd->start_time, rd->current_time, dt->delays[rd->frame], rd->inaccuracy);

        rd->start_time = GetTime();
        return 1;
    }
    else return 0;
}
